## Создание собственного образа nginx на базе alpine ##

Созданный в ходе выполнения домашнего задания кастомный образ nginx можно скачать командой:
```
docker pull denisko423/mynginx:1.0
```
Образ собран с помощью приложенного Dockerfile. За основу при его написании взят [docker-файл](https://github.com/nginxinc/docker-nginx/blob/41156d8a36bd03b2fb36353ba31f16ada08d9e48/mainline/alpine/Dockerfile), с помощью которого собран официальный docker-образ nginx для alpine.  
Цели, поставленные при сборке кастомного образа nginx - минимально возможные размер и количество слоев. Для этого:  
- все операции по подготовке и установке пакета nginx собраны в одной инструкции RUN,
- отключено локальное кэширование скачанных пакетов опцией --no-cache,
- конфиг nginx.conf и кастомная начальная страница nginx.html (приложены) копируются в ФС образа одной инструкцией COPY.  
Запущенный в контейнере кастомный nginx слушает на порту 8888, поэтому при создании контейнера на основе данного образа нужно указать проброс порта 8888 из контейнера на любой разрешенный (с точки зрения SELinux) порт хостовой системы опцией -p.  
Пример команды создания и запуска контейнера из образа:
```
docker run --name mynginx -d -p 80:8888 denisko423/mynginx:1.0
```
Во время работы nginx ведет логи error.log и access.log внутри контейнера в каталоге /var/log/nginx/. Чтобы иметь к ним доступ из хостовой системы, а также сохранить данные при удалении контейнера, следует смонтировать в указанный каталог папку из хостовой системы опцией -v. При выполнении следующей команды в текущем каталоге хостовой системы будет автоматически создана папка logs, которая после монтирования "заменит" каталог внутри контейнера /var/log/nginx/:
```
docker run --name mynginx -d -p 80:8888 -v $(pwd)/logs:/var/log/nginx denisko423/mynginx:1.0
```
Папка и логи внутри нее создаются от имени root, остальным пользователям они доступны в режиме "только чтение".  
После запуска контейнера начальная страница nginx открывается в браузере на локальном компьютере по ссылке [http://localhost](http://localhost).


## Разница между образом и контейнером ##

И образ, и контейнер на его основе имеют послойную структуру. В образе каждый слой соответствует инструкциям в Dockerfile, или, другими словами, при выполнении каждой инструкции добавляется новый слой. Все слои образа доступны только для чтения и являются статичными - их невозможно изменить или удалить.  
В созданном на основе образа контейнере добавляется отдельный слой, в котором и производятся все изменения в файловой системе внутри контейнера при его работе (создание/изменение/удаление объектов). По сути, контейнер - это именно этот RW слой и атрибуты, нужные для работы контейнера, в том числе ссылка на образ. Сам образ при этом в контейнер не копируется.  
Это дает возможность на основе одного образа создать несколько контейнеров, которые будут работать независимо друг от друга и не занимать много ресурсов - в памяти хостовой системы будет находиться один экземпляр образа, разделяемый между контейнерами, а все изменения внутри контейнеров будут производиться в областях, закрепленных за контейнерами.


## Возможно ли в контейнере собрать ядро ##

Точного ответа на этот вопрос я не нашел, на эксперименты нет времени. Поэтому могу только высказать предположение.  
Технология Docker по сути является разновидностью виртуализации - процесс работает в собственном изолированном окружении. Однако в отличие от полноценной виртуализации в Docker упор сделан на максимальном использовании ресурсов хостовой системы. Поэтому Docker-образ - то самое окружение для работы процесса - представляет из себя ОС и файловую систему, из которой "выпилено" всё, что можно задействовать во время работы из хостовой ОС, в том числе и в первую очередь ядро.  
Если понимать под сборкой ядра формирование файла (пакета) с новым ядром, то в контейнере такую операцию выполнить можно, установив необходимые инструменты. Но установить новое ядро внутри контейнера и тем более загрузить его невозможно - в файловой системе образа и контейнера отсутствует папка /boot, так как ядра и загрузчика там нет по определению. Остается только вариант передать пакет нового ядра в хостовую систему и использовать по назначению.  
Как упражнение сборка ядра (именно и только формирование пакета) в контейнере интересна теоретически, но практического смысла в ней нет.

