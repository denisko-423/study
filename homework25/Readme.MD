## Теоретическая часть ##

Начальный адрес диапазона адресов сети является ее собственным адресом. По адресу сети и маске узел определяет, принадлежит ли адрес получателя сообщения сети источника, и выбирает нужный маршрут. Узлам адрес сети не назначается.  
Также узлам не назначается последний адрес диапазона, это широковещательный (broadcast) адрес, сообщения с таким адресом принимают и обрабатывают все узлы данной сети.  
Таким образом, количество доступных для назначения узлам адресов в сети меньше общего количества адресов на 2, диапазон "начальный адрес"-"конечный адрес" включительно. Исключение - сеть с маской 255.255.255.254. Общий диапазон адресов такой сети состоит всего из двух адресов. Такие сети применяются, когда нужно соединить два узла, и точно известно, что других узлов в сети не будет, например, у провайдеров.  

Группа сетей "office1" представляет собой разбиение без остатка более крупной сети 192.168.2.0/24 (256 адресов) на 4 равных по размеру диапазона по 64 адреса в каждом.  
```
                 192.168.2.0/26 192.168.2.64/26 192.168.2.128/26 192.168.2.192/26
                |--------------|---------------|----------------|----------------|
 всего адресов    64              64              64               64
 всего узлов      62              62              62               62
 адрес сети       .0             .64            .128             .192
 начальный адрес  .1             .65            .129             .193
 конечный адрес  .62            .126            .190             .254
 broadcast       .63            .127            .191             .255
```
Группа сетей "office2" также получена разбиением на диапазоны более крупной сети 192.168.3.0/24 (256 адресов). Диапазоны не равные по размеру, остатка нет. Адрес сети я изменил на 192.168.3.0 для исключения пересечения с домашней сетью.  
```
               192.168.3.0/25                192.168.3.128/26     192.168.3.192/26
|-----------------------------------------|--------------------|--------------------|
 всего адресов   128                       всего адресов     64 всего адресов     64
 всего узлов     126                       всего узлов       62 всего узлов       62
 адрес сети       .0                       адрес сети      .128 адрес сети      .192
 начальный адрес  .1                       начальный адрес .129 начальный адрес .193
 конечный адрес .126                       конечный адрес  .190 конечный адрес  .254
 broadcast      .127                       broadcast       .191 broadcast       .255
```
Группа сетей "central" - результат разбиения на диапазоны сети 192.168.0.0/25 (128 адресов) (которая в свою очередь является первой половиной сети 192.168.0.0/24), 4 "куска" по 16 адресов и "остаток" 64 адреса. Два диапазона не задействованы, соответствуют сетям 192.168.0.16/28 и 192.168.0.48/28. Ошибок в разбиении нет, сети не пересекаются, возможно это резерв на будущее. К тому же пропуски можно ликвидировать, преобразовав имеющиеся сети 192.168.0.0/28 и 192.168.0.32/28 (по 16 адресов) в 192.168.0.0/27 и 192.168.0.32/27 (по 32 адреса).  
```
                  192.168.0.0             192.168.0.32             192.168.0.64
                  /28                     /28                      /26
                 |-----------|. . . . . .|------------|. . . . . .|------------|
 всего адресов     16          16          16           16           64
 всего узлов       14          14          14           14           62
 адрес сети        .0         .16         .32          .48          .64
 начальный адрес   .1         .17         .33          .49          .65
 конечный адрес   .14         .30         .46          .62         .126
 broadcast        .15         .31         .47          .63         .127
```












===========================================================================================
Созданный в ходе выполнения домашнего задания кастомный образ nginx можно скачать командой:
```
docker pull denisko423/mynginx:1.0
```
Образ собран с помощью приложенного Dockerfile. За основу при его написании взят [docker-файл](https://github.com/nginxinc/docker-nginx/blob/41156d8a36bd03b2fb36353ba31f16ada08d9e48/mainline/alpine/Dockerfile), с помощью которого собран официальный docker-образ nginx для alpine.  
Цели, поставленные при сборке кастомного образа nginx - минимально возможные размер и количество слоев. Для этого:  
- все операции по подготовке и установке пакета nginx собраны в одной инструкции RUN,
- отключено локальное кэширование скачанных пакетов опцией --no-cache,
- конфиг nginx.conf и кастомная начальная страница nginx.html (приложены) копируются в ФС образа одной инструкцией COPY.  

Запущенный в контейнере кастомный nginx слушает на порту 8888, поэтому при создании контейнера на основе данного образа нужно указать проброс порта 8888 из контейнера на любой разрешенный (с точки зрения SELinux) порт хостовой системы опцией -p.  
Пример команды создания и запуска контейнера из образа:
```
docker run --name mynginx -d -p 80:8888 denisko423/mynginx:1.0
```
Во время работы nginx ведет логи error.log и access.log внутри контейнера в каталоге /var/log/nginx/. Чтобы иметь к ним доступ из хостовой системы, а также сохранить данные при удалении контейнера, следует смонтировать в указанный каталог папку из хостовой системы опцией -v. При выполнении следующей команды в текущем каталоге хостовой системы будет автоматически создана папка logs, которая после монтирования "заменит" каталог внутри контейнера /var/log/nginx/:
```
docker run --name mynginx -d -p 80:8888 -v $(pwd)/logs:/var/log/nginx denisko423/mynginx:1.0
```
Папка и логи внутри нее создаются от имени root, остальным пользователям они доступны в режиме "только чтение".  
После запуска контейнера начальная страница nginx открывается в браузере на локальном компьютере по ссылке [http://localhost](http://localhost).


## Разница между образом и контейнером ##

И образ, и контейнер на его основе имеют послойную структуру. В образе каждый слой соответствует инструкциям в Dockerfile, или, другими словами, при выполнении каждой инструкции добавляется новый слой. Все слои образа доступны только для чтения и являются статичными - их невозможно изменить или удалить.  
В созданном на основе образа контейнере добавляется отдельный слой, в котором и производятся все изменения в файловой системе внутри контейнера при его работе (создание/изменение/удаление объектов). По сути, контейнер - это именно этот RW слой и атрибуты, нужные для работы контейнера, в том числе ссылка на образ. Сам образ при этом в контейнер не копируется.  
Это дает возможность на основе одного образа создать несколько контейнеров, которые будут работать независимо друг от друга и не занимать много ресурсов - в памяти хостовой системы будет находиться один экземпляр образа, разделяемый между контейнерами, а все изменения внутри контейнеров будут производиться в областях, закрепленных за контейнерами.


## Возможно ли в контейнере собрать ядро ##

Точного ответа на этот вопрос я не нашел, на эксперименты нет времени. Поэтому могу только высказать предположение.  
Технология Docker по сути является разновидностью виртуализации - процесс работает в собственном изолированном окружении. Однако в отличие от полноценной виртуализации в Docker упор сделан на максимальном использовании ресурсов хостовой системы. Поэтому Docker-образ - то самое окружение для работы процесса - представляет из себя ОС и файловую систему, из которой "выпилено" всё, что можно задействовать во время работы из хостовой ОС, в том числе и в первую очередь ядро.  
Если понимать под сборкой ядра формирование файла (пакета) с новым ядром, то в контейнере такую операцию выполнить можно, установив необходимые инструменты. Но установить новое ядро внутри контейнера и тем более загрузить его невозможно - в файловой системе образа и контейнера отсутствует папка /boot, так как ядра и загрузчика там нет по определению. Остается только вариант передать пакет нового ядра в хостовую систему и использовать по назначению.  
Как упражнение сборка ядра (именно и только формирование пакета) в контейнере интересна теоретически, но практического смысла в ней нет.

