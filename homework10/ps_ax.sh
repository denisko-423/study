#!/bin/bash

# Заголовок вывода.
echo "    PID TTY      STAT    TIME COMMAND"

# Длину выводимой части командной строки вычисляем на основании
# ширины окна терминала (cols), фиксированное значение.
cmdlen=$(($(tput cols)-30))

# Получаем перечень PID всех процессов - каталоги (ls -d) в /proc с именами,
# состоящими только из цифр (grep). Сортируем по возрастанию (sort).
prc=`ls -d /proc/* | sed 's/\/proc\///' | grep -Eo '^[0-9]*$' | sort -g`

# Цикл перебора всех PID
for i in $prc; do

# Некоторые процессы, судя по всему порожденные при выполнении скрипта,
# завершаются, исчезают и соотв. каталоги. Проверяем каталог на существование.
  test -e /proc/$i && {

# Терминалы, связанные с процессом, получаем из каталога /proc/<PID>/fd,
# где находится перечень открытых процессом файлов с соотв. файловыми дескрипторами.
# По сравнению с выводом команды ps ax в выводе скрипта есть отличия.
# Например, на моем компьютере ps ax для процесса /usr/libexec/gnome-session-binary
# указывает связанный терминал tty2, но в каталоге процесса /proc/<PID>/fd
# нет симлинка на /dev/tty2, скрипт ставит для процесса "?".
    tty=`ls -l /proc/$i/fd | grep -o '/dev/[pt]t[sy].*' | sed 's/\/dev\///' | uniq`

# С процессом может быть связано более одного терминала.
# ps ax для таких процессов показывает знак "?", скрипт дает ошибку.
# Как интерпретировать такую ситуацию - не знаю.
# Такую конструкцию пришлось "сгородить", чтобы вывод совпадал с "эталонным" (ps ax).
    test $tty 2>/dev/null || tty="?"

# В основном нужная информация содержится в файле /proc/<PID>/stat.
# После чтения файла получаем массив данных.
    read -a stat <<< `cat /proc/$i/stat`

# Дополнительный статус:
# <, N - high (low) priority
# получаем на основании "вежливости" (nice) процесса.
    if [[ ${stat[18]} -gt 0 ]]; then pr="N"; elif [[ ${stat[18]} -lt 0 ]]; \
    then pr="<"; else pr=""; fi

# Дополнительный статус:
# s - session leader
# "process ID" == "session ID of the process"
    [[ ${stat[0]} -eq ${stat[5]} ]] && sl="s" || sl=""

# Дополнительный статус:
# l - multi-threaded
# "number of threads in this process" > 1
    [[ ${stat[19]} -gt 1 ]] && mt="l" || mt=""

# Дополнительный статус:
# + - is in the foreground process group
# "process group ID" == "ID of the foreground process group"
    [[ ${stat[4]} -eq ${stat[7]} ]] && fgpg="+" || fgpg=""

# Дополнительный статус:
# L - has pages locked into memory
# получаем из файла /proc/<PID>/status ("VmLck" > 0).
    a=`awk '{if ($1=="VmLck:") print $2;}' /proc/$i/status`
    [[ ${a} -eq 0 ]] && lp="" || lp="L"

# Рассчитываем время, потраченное процессором на выполнение процесса
# (utime + stime в сотых долях секунды).
    t=$(((${stat[13]}+${stat[14]})/100))
    minutes=$(($t/60))
    seconds=$(($t%60))

# Командную строку получаем из файла /proc/<PID>/cmdline
# с заменой на пробелы разделителей - байтов 0x00,
# если файл пустой - из поля "comm" файла /proc/<PID>/stat.
# Обрезаем лишнее (под ширину окна терминала).
    cmd="`cat /proc/$i/cmdline | tr "\0" " "`"
    [[ "$cmd" ]] && cmd="${cmd:0:$cmdlen}" || cmd="["${stat[1]:1:-1}"]"

# Форматированный вывод.
    printf "%7s %-8s %-4s %4d:%02d %-s\n" \
    ${stat[0]} ${tty} ${stat[2]}${pr}${lp}${sl}${mt}${fgpg} ${minutes} ${seconds} "${cmd}"

  }
done

